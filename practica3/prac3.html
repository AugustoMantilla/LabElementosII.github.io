<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Práctica 3 | Ibero Puebla</title>
        <!-- Favicon-->
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Bootstrap icons-->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel="stylesheet" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />

        <style>
            pre {
                background-color: #fefcfc;
                color: #373e43;
                padding: 15px;
                border-radius: 5px;
                overflow-x: auto;
                white-space: pre-wrap; /* Para que el código se ajuste al contenedor */
                font-size: 14px;
                line-height: 1;
            }
        </style>
    </head>
    <body class="d-flex flex-column h-100">
        <main class="flex-shrink-0">
            <!-- Navigation-->
            <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
                <div class="container px-5">
                    <a class="navbar-brand">Menu</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarSupportedContent">
                        <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
                            <li class="nav-item"><a class="nav-link" href="../">Home</a></li>                    
                            <li class="nav-item"><a class="nav-link" href="../index.html#resumen">Acerca de mi</a></li>
                            <li class="nav-item"><a class="nav-link" href="../index.html#practicas">Prácticas</a></li>
                        </ul>
                    </div>
                </div>
            </nav>

            <!-- Seccion TITULO de Portafolio-->
            <header class="bg-primary py-2 mt-6">
                <div class="container px-5">
                    <div class="row gx-5 align-items-center justify-content-center">
                        <div class="col-lg-8 col-xl-7 col-xxl-6">
                            <div class="my-5 text-center text-xl-start">
                                <h1 class="display-6 fw-bolder text-white mb-2">Portafolio de Actividades</h1>
                                <h1 class="display-8 fw-bolder text-white mb-2">Laboratorio Elementos Programables II</h1>
                                <p id="resumen" class="display-8 fw-normal text-white-50 mb-4">Departamento de Ciencias e Ingenierías | Universidad Iberoamericana Puebla, México.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Seccion TITULO de la Práctica-->
            <section class="py-3" id="scroll-target">
                <div class="container px-5 my-2">
                    <!-- Post header-->
                    <header class="mb-4">
                        <!-- Post title-->
                        <h1 class="fw-bolder mb-1">Velocidad de comunicación serial</h1>

                        <!-- ETIQUETA DE ALUMNO (Hacer una por cada alumno)-->
                            <div class="ms-2">
                                <div class="fw-bold">Augusto Mantilla Molina</div>
                                <div class="text-muted">Ingeniería Mecatrónica</div>
                            </div>

                            <div class="ms-2">
                                <div class="fw-bold">Carlos Juarez Galicia</div>
                                <div class="text-muted">Ingeniería Mecatrónica</div>
                            </div>
                        <!--Aqui termina etiqueta de alumno-->

                        <div class="text-muted fst-italic mt-2 mb-2">Fecha: Marzo 20, 2025</div>
                        <!-- ETIQUETAS O TOPICOS IMPORTANTES DE LA PRACTICA-->
                        <a class="badge bg-primary text-decoration-none link-light" >Arduino</a>
                        <a class="badge bg-primary text-decoration-none link-light" >ESP32</a>
                        <a class="badge bg-primary text-decoration-none link-light" >ATtiny85</a>

                    </header>
                </div>
            </section>

            <!-- Seccion de CONTENIDO de la Práctica-->
            <section>
                <div class="container px-5">

                    <figure class="mb-4"><img class="img-fluid rounded" width="800px" src="img/" alt="..." /></figure>
                        <p id="intro">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5" >- Introducción -</h2>
                        <p class="fs-6 mb-4">
                            La comunicación serial es un protocolo estandarizado que permite el intercambio de información en 
                            forma de bits entre dos o más dispositivos. Existen 2 formas de realizar esta comunicación.
                        </p>
                        <h2 class="fw-bolder mb-4 mt-5 fs-5" ><b>Conexión vía USB</b></h2>
                        <p class="fs-6 mb-4">
                            Es la conexión más sencilla y lo único que necesitarás es el cable usb de tus dispositivos. Muchos 
                            microcontroladores usan la comunicación serial, pero las computadoras modernas utilizan USB. 
                            Para conectar ambos, se usa un adaptador USB-UART.
                        </p>
                        <center><figure class="mb-4"><img class="img-fluid rounded" width="400px" src="img/pc1.png" alt="..." /></figure></center>

                        <h2 class="fw-bolder mb-4 mt-5 fs-5" ><b>Conexión vía pines RX/TX</b></h2>
                        <p class="fs-6 mb-4">
                            La comunicación serial mediante pines es un método utilizado para la transmisión de datos entre 
                            dispositivos electrónicos, como microcontroladores, sensores y módulos de comunicación. Utiliza dos 
                            pines principales:
                        </p>

                        <p class="fs-6 mb-4">
                            <ul>
                                <li><b>TX (Transmisión):</b> Envía datos.</li>
                                <li><b>RX (Recepción):</b> Recibe datos.</li>
                            </ul>
                        </p>
                        <center><figure class="mb-4"><img class="img-fluid rounded" width="400px" src="img/t725.png" alt="..." /></figure></center>

                        <p id="materiales">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5" >- Materiales -</h2>
                        <p class="fs-6 mb-4">
                            <ul>
                                <li>ESP32: 1</li>
                                <li>Arduino UNO: 1</li>
                            </ul>
                        </p>
                        <p id="desarrollo">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Desarrollo -</h2>
                        <p class="fs-6 mb-4">
                            En esta práctica, se evaluará el tiempo de ida y vuelta de una comunicación serial entre un 
                            microcontrolador y una computadora. Para ello, se enviará un dato desde la PC hacia el microcontrolador, 
                            el cual responderá con el mismo dato, y se medirá el tiempo transcurrido en la PC.
                        </p>
                        <p class="fs-6 mb-4">
                            El objetivo es analizar la latencia en la comunicación serial y obtener un promedio del tiempo de 
                            respuesta después de 100 iteraciones.
                        </p>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Instalación de Python</b></h1>
                            <p class="fs-6 mb-4">
                                Para esta práctica, es necesario descargar <b>Python</b> porque se utilizará para establecer la 
                                comunicación serial entre la PC y el microcontrolador mediante la librería <pre>pyserial</pre>, 
                                la cual permite enviar y recibir datos a través del puerto USB. Además, Python nos permite 
                                medir con precisión el tiempo de ida y vuelta de los datos, realizar múltiples iteraciones y 
                                calcular el tiempo promedio de respuesta, algo que no se puede hacer directamente desde el IDE de 
                                Arduino.
                            </p>

                            <pre>
                                import serial
                                import time

                                micro = serial.Serial("COM15", 2000000, timeout=0.1)
                                time.sleep(2)

                                tiempos = []  

                                for i in range(100):
                                micro.reset_input_buffer() 
                                inicio = time.perf_counter()  

                                micro.write(b"A")
                                respuesta = micro.readline().decode().strip()  
                                if respuesta == "A": 
                                fin = time.perf_counter()  
                                rtt = (fin - inicio) * 1000 
                                tiempos.append(rtt)

                                if tiempos:
                                promedio = sum(tiempos) / len(tiempos)
                                print(f"{promedio:.4f}")

                                micro.close()
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Explicación</b></h1>
                            <p class="fs-6 mb-4">
                                Se importan las librerías serial para la comunicación serie y time para manejar tiempos y retardos.
                            </p>

                            <p class="fs-6 mb-4">
                                Se crea una instancia de serial.Serial para comunicarse por medio del  puerto "COMX" a una 
                                velocidad de X baudios, con un tiempo de espera de 0.1 segundos.
                            </p>

                            <p class="fs-6 mb-4">
                                Se espera 2 segundos para asegurar que la conexión esté establecida.
                            </p>

                            <p class="fs-6 mb-4">
                                Se crea una lista para guardar los tiempos de ida y vuelta
                            </p>

                            <p class="fs-6 mb-4">
                                Se crea un buble de 100 interaciones en donde:
                            </p>
                            <p class="fs-6 mb-4">
                                <ol>
                                    <li>Se limpia el buffer de entrada del puerto serie. </li>
                                    <li>Se registra el tiempo de inicio.</li>
                                    <li>Se envía un byte "A" al dispositivo.</li>
                                    <li>Se lee la respuesta del dispositivo.</li>
                                    <li>Si la respuesta es "A", se registra el tiempo de fin.</li>
                                    <li>Se calcula el tiempo de ida y vuelta en milisegundos y se añade a la lista tiempos.</li>
                                </ol>
                            </p>
                            
                            <p class="fs-6 mb-4">
                                Cuando se termina de recopilar los tiempos, se calcula el promedio del tiempo de ida y vuelta 
                                y se imprime con cuatro decimales.
                            </p>

                            <p class="fs-6 mb-4">
                                Por último, se cierra la conexión del puerto serie.
                            </p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Memoria Flash</b></h3>

                            <p class="fs-6 mb-4">
                                En la función setup(), que se ejecuta una sola vez al inicio, se inicia la comunicación serial 
                                a 9600 baudios y se calcula el tamaño de la memoria flash sumando 1 a FLASHEND, que representa 
                                la última dirección de memoria disponible. Luego, el resultado se convierte a kilobytes 
                                dividiendo entre 1024.0 y se imprime en el monitor serial.
                            </p>

                            <pre>
                                void setup() {
                                // Iniciar la comunicación serial
                                Serial.begin(9600);

                                // Calcular el tamaño de la memoria flash en bytes
                                uint16_t flashSize = FLASHEND + 1; // FLASHEND es la última dirección de memoria flash

                                // También puedes mostrarlo en kilobytes
                                Serial.print("Tamaño de la memoria flash: ");
                                Serial.print(flashSize / 1024.0);
                                Serial.println(" KB");
                                }

                                void loop() {
                                }
                                  
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/424701313363341313"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/memoria_flash_arduino.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/Memoria_FLASH.ino">Arduino Memoria Flash</a></p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Memoria RAM</b></h3>

                            <p class="fs-6 mb-4">
                                En la función setup(), que se ejecuta una sola vez al inicio, se inicia la comunicación serial a 
                                9600 baudios. Luego, en la función loop(), que se ejecuta 
                                repetidamente, se llama a la función freeRam(), que calcula la memoria RAM disponible utilizando 
                                las variables del sistema __heap_start y __brkval, y el resultado se imprime en el monitor 
                                serial cada 3 segundos.
                            </p>

                            <pre>
                                void setup(){
                                    Serial.begin(9600);
                                    Serial.println("Comienza...");
                                  }
                                  
                                  void loop(){
                                    Serial.println(freeRam());
                                    
                                    delay(3000);
                                  }
                                  
                                  int freeRam () 
                                  {
                                    extern int __heap_start, *__brkval; 
                                    int v; 
                                    return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval); 
                                  }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/424701586945245185"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/memoria_RAM_arduino.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/Memoria_RAM_Arduino.ino">Arduino Memoria RAM</a></p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Comunicacion UART-SERIAL</b></h3>

                            <p class="fs-6 mb-4">
                                En la función setup(), que se ejecuta una sola vez al inicio, se inicializa la comunicación 
                                serial a 9600 baudios y se imprime el mensaje "Monitor Serial Iniciado. Escribe algo:". Luego, 
                                en la función loop(), que se ejecuta repetidamente, se verifica si hay datos disponibles en el 
                                buffer serial, y si es así, se leen hasta encontrar un salto de línea (\n).
                            </p>

                            <pre>
                                void setup() {
                                    Serial.begin(9600); // Inicializa el Monitor Serial a 9600 baudios
                                    Serial.println("Monitor Serial Iniciado. Escribe algo:");
                                }
                                
                                void loop() {
                                    if (Serial.available() > 0) { // Verifica si hay datos en el buffer serial
                                        String entrada = Serial.readStringUntil('\n'); // Lee el dato ingresado
                                        Serial.print("Recibido: ");
                                        Serial.println(entrada); // Muestra el dato en el monitor serial
                                    }
                                }
                                
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/424702321394163713"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/UART_ARDUINO.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/UART.ino">Arduino UART</a></p>



                            

                            <h2 class="fw-bolder mb-4 mt-5 fs-5"><b>ESP32</b></h2>
                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Velocidad de procesamiento</b></h3>

                            <p class="fs-6 mb-4">
                                En la función setup(), que se ejecuta una sola vez al inicio, se inicializa la comunicación 
                                serial a 115200 baudios y se guarda el tiempo inicial en microsegundos con micros(). Luego, se 
                                ejecuta un bucle que realiza un millón de operaciones simples de multiplicación, almacenando 
                                el resultado en una variable volatile. Al finalizar, 
                                se guarda el tiempo final y se calcula el tiempo total transcurrido. 
                                Finalmente, se determina la cantidad de operaciones por segundo dividiendo el número de 
                                operaciones entre el tiempo en segundos y se muestra el resultado en el monitor serial. 
                            </p>

                            <pre>
                                unsigned long tiempoInicio, tiempoFin;
                                const int operaciones = 1000000; // Número de operaciones a medir

                                void setup() {
                                    Serial.begin(115200); // Inicializa el Monitor Serial a 115200 baudios
                                    tiempoInicio = micros(); // Guarda el tiempo inicial en microsegundos

                                    for (int i = 0; i < operaciones; i++) {
                                        volatile int x = i * 2; // Operación simple para evaluar velocidad
                                    }

                                    tiempoFin = micros(); // Guarda el tiempo final en microsegundos
                                    unsigned long tiempoTotal = tiempoFin - tiempoInicio;

                                    float operacionesPorSegundo = (operaciones / (tiempoTotal / 1000000.0));
                                    Serial.print("Operaciones por segundo: ");
                                    Serial.println(operacionesPorSegundo);
                                }

                                void loop() {

                                }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/424715078722659329"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/vel_procesamiento_esp32.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/vel_procesamiento_esp32.ino">ESP32 Velocidad de procesamiento</a></p>
                            
                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Memoria Flash</b></h3>

                            <p class="fs-6 mb-4">
                                En la función setup(), que se ejecuta una sola vez al inicio, se inicializa la comunicación 
                                serial a 115200 baudios y se obtiene el tamaño de la memoria flash utilizando 
                                ESP.getFlashChipSize(). Luego, se imprime el tamaño en bytes.
                            </p>

                            <pre>
                                void setup() {
                                    // Iniciar la comunicación serial
                                    Serial.begin(115200);
                                    
                                    // Obtener el tamaño de la memoria flash
                                    uint32_t flashSize = ESP.getFlashChipSize();
                                  
                                    // Mostrar el tamaño de la memoria flash en bytes
                                    Serial.print("Tamaño de la memoria flash: ");
                                    Serial.print(flashSize);
                                    Serial.println(" bytes");
                                  }
                                  
                                  void loop() {
                                    // No es necesario hacer nada en el loop
                                  }
                                  
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/424715513770573825"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/memoria_flash_ESP32.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/Memoria_FLASH_ESP32.ino">ESP32 Memoria Flash</a></p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Memoria RAM</b></h3>

                            <p class="fs-6 mb-4">
                                En la función setup(), que se ejecuta una sola vez al inicio, se inicializa la comunicación serial a 
                                115200 baudios y se obtiene la cantidad de memoria RAM libre utilizando ESP.getFreeHeap(). Luego, este 
                                valor se imprime en el monitor serial en bytes.
                            </p>

                            <pre>
                                void setup() {
                                    // Iniciar la comunicación serial
                                    Serial.begin(115200);
                                  
                                    // Calcular la memoria RAM disponible
                                    int freeRAM = ESP.getFreeHeap();
                                  
                                    // Mostrar la memoria RAM disponible en el monitor serial
                                    Serial.print("Memoria RAM: ");
                                    Serial.print(freeRAM);
                                    Serial.println(" bytes");
                                  }
                                  
                                  void loop() {
                                    // No es necesario hacer nada en el loop para esta tarea
                                  }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/424718476182612993"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/memoria_ram_ESP32.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/Memoria_RAM.ino">ESP32 Memoria RAM</a></p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Comunicacion UART-SERIAL</b></h3>

                            <p class="fs-6 mb-4">
                                En la función setup(), que se ejecuta una sola vez al inicio, se inicializa la comunicación 
                                serial a 115200 baudios y se imprime el mensaje "Monitor Serial Iniciado". Luego, en la función 
                                loop(), que se ejecuta de forma continua, se imprime el mensaje "Hola, ESP32 está funcionando" 
                                en el monitor serial cada segundo.
                            </p>

                            <pre>
                                void setup() {
                                    Serial.begin(115200); // Inicia la comunicación serial a 115200 baudios
                                    Serial.println("Monitor Serial Iniciado");
                                  }
                                  
                                  void loop() {
                                    Serial.println("Hola, ESP32 está funcionando");
                                    delay(1000); // Espera 1 segundo
                                  }                                  
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/426703347950707713"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/UART ESP32.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/UART_ESP32.ino">ESP32 UART</a></p>


                            <h2 class="fw-bolder mb-4 mt-5 fs-5"><b>ATtiny85</b></h2>
                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Velocidad de procesamiento</b></h3>

                            <p class="fs-6 mb-4">
                                En la función setup(), se configura el pin del buzzer como salida y se guarda el tiempo inicial 
                                en microsegundos. En la función loop(), se ejecuta un bucle con una instrucción para simular una 
                                operación intensiva, tras lo cual se calcula el tiempo total transcurrido restando el tiempo 
                                inicial del tiempo final obtenido. Luego, el buzzer emite un sonido de 1000 Hz durante 20000 ms 
                                para indicar que la tarea ha finalizado.
                            </p>

                            <pre>
                                const int buzzerPin = 4;
                                unsigned long tiempoInicio;
                                unsigned long tiempoFinal;
                                unsigned long tiempoTotal;
                                
                                void setup() {
                                  pinMode(buzzerPin, OUTPUT);
                                  tiempoInicio = micros();
                                }
                                
                                void loop() {
                                  for (volatile long i = 0; i < 1000000; i++) {
                                    __asm__ __volatile__ ("nop");
                                  }
                                
                                  tiempoFinal = micros();
                                  tiempoTotal = tiempoFinal - tiempoInicio;
                                
                                  tone(buzzerPin, 1000, 20000);
                                  delay(500);
                                
                                  tiempoInicio = micros();
                                }
                                
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/426790149026068481"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/vel_attiny.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/AT85_Vel_Proc.ino">ATtiny85 Velocidad de Procesamiento</a></p>
                            
                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Memoria Flash</b></h3>

                            <p class="fs-6 mb-4">
                                El ATtiny85 cuenta con 8 KB (8192 bytes) de memoria Flash de tipo ISP. Esto significa que se 
                                puede programar y reprogramar sin necesidad de extraer el microcontrolador del circuito, 
                                utilizando interfaces como SPI o un programador externo.
                            </p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Memoria RAM</b></h3>

                            <p class="fs-6 mb-4">
                                El ATtiny85 cuenta con 512 bytes de memoria SRAM, que se usa para almacenar variables en tiempo 
                                de ejecución, la pila de ejecución y datos temporales. Está organizada en un espacio de 
                                direcciones donde los primeros 32 bytes son registros de propósito general, seguidos de 64 bytes 
                                reservados para periféricos, dejando el resto disponible para el usuario.
                            </p>
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Comparación finnal de los microcontroladores</b></h1>
                            <style>
                                .mi-tabla {
                                  width: 100%;
                                  border-collapse: collapse; /* Colapsa los bordes para que no haya espacio entre celdas */
                                }
                                .mi-tabla th, .mi-tabla td {
                                  border: 1px solid black; /* Bordes de 1px sólidos y negros para todas las celdas */
                                  padding: 8px; /* Espaciado interno para las celdas */
                                  text-align: left; /* Alineación del texto */
                                }
                                .mi-tabla th {
                                  background-color: #f2f2f2; /* Color de fondo para las celdas de la cabecera */
                                }
                            </style>
                              
                            <table class="mi-tabla">
                                <tr>
                                  <th>Característica</th>
                                  <th>ESP32</th>
                                  <th>Arduino UNO</th>
                                  <th>ATtiny85</th>
                                </tr>
                                <tr>
                                  <td>Velocidad de procesamiento</td>
                                  <td>160 MHz </td>
                                  <td>16 MHz</td>
                                  <td>1 MHz</td>
                                </tr>
                                <tr>
                                  <td>Memoria Flash</td>
                                  <td>4 MB</td>
                                  <td>32 KB</td>
                                  <td>8 KB</td>
                                </tr>
                                <tr>
                                    <td>Memoria RAM</td>
                                    <td>512 KB</td>
                                    <td>2 KB</td>
                                    <td>512 Bytes</td>
                                </tr>
                                <tr>
                                    <td>Puertos USART (UART)</td>
                                    <td>2</td>
                                    <td>1</td>
                                    <td>No cuenta con uno propio</td>
                                </tr>
                                <tr>
                                    <td>Multitareas</td>
                                    <td>Si, ya que cuenta con 2 nucleos</td>
                                    <td>No</td>
                                    <td>No</td>
                                </tr>
                            </table>
                            <div>
                        <p id="conclusiones">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Conclusiones -</h2>
                        <p class="fs-6 mb-4">
                            A lo largo de esta práctica se pudo ver que el ESP32 es el más potente de los tres microcontroladores, 
                            destacando por su alta velocidad de procesamiento, mayor memoria tanto flash como RAM, 
                            su capacidad para multitareas.
                        </p>

                        <p id="referencias">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Referencias -</h2>
                        <p class="fs-6 mb-4">Santos, S., & Santos, S. (2024, 24 octubre). ESP32 Pinout Reference: Which GPIO pins should you use? | Random Nerd Tutorials. Random Nerd Tutorials. <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">https://randomnerdtutorials.com/esp32-pinout-reference-gpios/</a> </p>
                        <p class="fs-6 mb-4">The Full Arduino Uno Pinout Guide [including diagram]. (2018, 18 noviembre). circuito.io Blog. <a href="https://www.circuito.io/blog/arduino-uno-pinout/"> https://www.circuito.io/blog/arduino-uno-pinout/</a></p>
                        <p class="fs-6 mb-4">Homemade hardware. (s. f.). <a href="http://homemadehardware.com/guides/programming-an-attiny85/"> http://homemadehardware.com/guides/programming-an-attiny85/</a></p>
                        
                        <p id="descargables">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Descargables -</h2>
                        <p class="fs-6 mb-4">Arduino UNO Datasheet: <a href="files/A000066.PDF">Arduino UNO.pdf</a> </p>
                        <p class="fs-6 mb-4">ESP32 Datasheet: <a href="files/esp32-wroom-32_datasheet_en.pdf">ESP32.pdf</a> </p>
                        <p class="fs-6 mb-4">Attiny85 Datasheet: <a href="files/ATTINY25.PDF">Attiny85.pdf</a> </p>
                        <p class="fs-6 mb-4">Descargar carpeta con todos los códigos: <a href="files/Codigos.zip">códigos.zip</a> </p>

                </div>
            </section>

            
        </main>

        <!-- Footer-->
        <footer class="bg-dark py-4 mt-auto">
            <div class="container px-5">
                <div class="row align-items-center justify-content-between flex-column flex-sm-row">
                    <div class="col-auto"><div class="small m-0 text-white">Copyright &copy; Ingenierias-iberopuebla.mx 2023</div></div>
                    <div class="col-auto">
                        <a class="link-light small" href="#!">Privacy</a>
                        <span class="text-white mx-1">&middot;</span>
                        <a class="link-light small" href="#!">Terms</a>
                        <span class="text-white mx-1">&middot;</span>
                        <a class="link-light small" href="#!">Contact</a>
                    </div>
                </div>
            </div>
        </footer>

        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
