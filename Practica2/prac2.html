<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Práctica 2 | Ibero Puebla</title>
        <!-- Favicon-->
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Bootstrap icons-->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel="stylesheet" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />

        <style>
            pre {
                background-color: #fefcfc;
                color: #373e43;
                padding: 15px;
                border-radius: 5px;
                overflow-x: auto;
                white-space: pre-wrap; /* Para que el código se ajuste al contenedor */
                font-size: 14px;
                line-height: 1;
            }
        </style>
    </head>
    <body class="d-flex flex-column h-100">
        <main class="flex-shrink-0">
            <!-- Navigation-->
            <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
                <div class="container px-5">
                    <a class="navbar-brand">Menu</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarSupportedContent">
                        <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
                            <li class="nav-item"><a class="nav-link" href="../">Home</a></li>                    
                            <li class="nav-item"><a class="nav-link" href="../index.html#resumen">Acerca de mi</a></li>
                            <li class="nav-item"><a class="nav-link" href="../index.html#practicas">Prácticas</a></li>
                        </ul>
                    </div>
                </div>
            </nav>

            <!-- Seccion TITULO de Portafolio-->
            <header class="bg-primary py-2 mt-6">
                <div class="container px-5">
                    <div class="row gx-5 align-items-center justify-content-center">
                        <div class="col-lg-8 col-xl-7 col-xxl-6">
                            <div class="my-5 text-center text-xl-start">
                                <h1 class="display-6 fw-bolder text-white mb-2">Portafolio de Actividades</h1>
                                <h1 class="display-8 fw-bolder text-white mb-2">Laboratorio Elementos Programables II</h1>
                                <p id="resumen" class="display-8 fw-normal text-white-50 mb-4">Departamento de Ciencias e Ingenierías | Universidad Iberoamericana Puebla, México.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Seccion TITULO de la Práctica-->
            <section class="py-3" id="scroll-target">
                <div class="container px-5 my-2">
                    <!-- Post header-->
                    <header class="mb-4">
                        <!-- Post title-->
                        <h1 class="fw-bolder mb-1">Capacidades de los microcontroladores</h1>

                        <!-- ETIQUETA DE ALUMNO (Hacer una por cada alumno)-->
                            <div class="ms-2">
                                <div class="fw-bold">Augusto Mantilla Molina</div>
                                <div class="text-muted">Ingeniería Mecatrónica</div>
                            </div>

                            <div class="ms-2">
                                <div class="fw-bold">Carlos Juarez Galicia</div>
                                <div class="text-muted">Ingeniería Mecatrónica</div>
                            </div>
                        <!--Aqui termina etiqueta de alumno-->

                        <div class="text-muted fst-italic mt-2 mb-2">Fecha: Febrero 20, 2025</div>
                        <!-- ETIQUETAS O TOPICOS IMPORTANTES DE LA PRACTICA-->
                        <a class="badge bg-primary text-decoration-none link-light" >Arduino</a>
                        <a class="badge bg-primary text-decoration-none link-light" >ESP32</a>
                        <a class="badge bg-primary text-decoration-none link-light" >ATtiny85</a>

                    </header>
                </div>
            </section>

            <!-- Seccion de CONTENIDO de la Práctica-->
            <section>
                <div class="container px-5">

                    <figure class="mb-4"><img class="img-fluid rounded" width="800px" src="img/portada reporte1.jpg" alt="..." /></figure>

                        <p id="intro">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5" >- Introducción -</h2>
                        <p class="fs-6 mb-4">
                            Las diferentes capacidades de los microcontroladores varían dependiendo de diversos factores. 
                            Un ejemplo es su finalidad, es decir, si se requiere que el microcontrolador ejecute tareas sencillas 
                            o complejas. A lo largo de esta práctica, analizaremos las distintas capacidades del ATtiny85, 
                            Arduino UNO y ESP32.
                        </p>
                        <p class="fs-6 mb-4">
                            Las características en las que nos enfocaremos para la evaluación son las siguientes:
                        </p>
                        <p class="fs-6 mb-4">
                            <ul>
                                <li><b>Velocidad de procesamiento</b></li>
                                <li><b>Memoria: </b>Flash y RAM</li>
                                <li><b>Comunicación UART-SERIAL</b></li>
                                <li><b>Capacidad de multitarea (hilos)</b></li>
                            </ul>
                        </p>

                        <p id="materiales">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5" >- Materiales -</h2>
                        <p class="fs-6 mb-4">
                            <ul>
                                <li>ESP32: 1</li>
                                <li>Arduino UNO: 1</li>
                                <li>ATtiny85: 1</li>
                                <li>Diodo LED: 2</li>
                                <li>Resistencias 300Ω: 2</li>
                                <li>Cable Jumper: 16</li>
                            </ul>
                        </p>
                        <p id="desarrollo">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Desarrollo -</h2>
                        <p class="fs-6 mb-4">
                            Para comenzar con esta práctica, es necesario tener conocimientos básicos sobre los tres 
                            microcontroladores que vamos a utilizar. Si deseas conocer más sobre ellos, <a href="https://augustomantilla.github.io/LabElementosII.github.io/practica1/">haz clic aquí</a>, 
                            donde encontrarás información sobre sus características, cómo programarlos y otros detalles.
                        </p>
                        <p class="fs-6 mb-4">
                            Teniendo esto claro, comenzaremos analizando la velocidad de procesamiento, luego evaluaremos la 
                            memoria Flash y RAM, posteriormente revisaremos la comunicación UART-SERIAL, y finalmente, 
                            exploraremos la capacidad de multitarea (hilos).
                        </p>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Velocidad de procesamiento</b></h1>
                            <h2 class="fw-bolder mb-4 mt-5 fs-5"><b>Arduino UNO</b></h2>
                            <p class="fs-6 mb-4">
                                Este código mide cuántas veces se ejecuta el ciclo loop() en un segundo. 
                                En la función setup(), que se ejecuta una sola vez al inicio, se inicia la comunicación serial 
                                y se guarda el tiempo inicial con millis(). Luego, en la función loop(), que se ejecuta 
                                repetidamente, se incrementa un contador en cada iteración y se actualiza el tiempo actual. 
                                Si ha pasado un segundo, se imprime en el monitor serial la cantidad de bucles ejecutados en ese 
                                tiempo.
                            </p>

                            <pre>
                                unsigned long startTime;
                                unsigned long endTime;
                                unsigned long loopCount = 0;

                                void setup() {
                                    Serial.begin(9600);  // Inicia la comunicación serial
                                    startTime = millis(); // Guarda el tiempo inicial
                                }

                                void loop() {
                                    loopCount++; // Incrementa el contador de bucles
                                    endTime = millis(); // Guarda el tiempo actual

                                    if (endTime - startTime >= 1000) {
                                        Serial.print("Bucles por segundo: ");
                                        Serial.println(loopCount);

                                        loopCount = 0; // Reinicia el contador de bucles
                                        startTime = millis(); // Reinicia el tiempo inicial
                                    }
                                }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/424656937511284737"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/vel_procesamiento_arduino.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>

                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/Velocidad_Arduino.ino">Arduino Velocidad de procesamiento</a></p>
                            
                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Memoria Flash</b></h3>

                            <p class="fs-6 mb-4">
                                En la función setup(), que se ejecuta una sola vez al inicio, se inicia la comunicación serial 
                                a 9600 baudios y se calcula el tamaño de la memoria flash sumando 1 a FLASHEND, que representa 
                                la última dirección de memoria disponible. Luego, el resultado se convierte a kilobytes 
                                dividiendo entre 1024.0 y se imprime en el monitor serial.
                            </p>

                            <pre>
                                void setup() {
                                // Iniciar la comunicación serial
                                Serial.begin(9600);

                                // Calcular el tamaño de la memoria flash en bytes
                                uint16_t flashSize = FLASHEND + 1; // FLASHEND es la última dirección de memoria flash

                                // También puedes mostrarlo en kilobytes
                                Serial.print("Tamaño de la memoria flash: ");
                                Serial.print(flashSize / 1024.0);
                                Serial.println(" KB");
                                }

                                void loop() {
                                }
                                  
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/424701313363341313"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/memoria_flash_arduino.mp4 type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/Memoria_FLASH.ino">Arduino Memoria Flash</a></p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Memoria RAM</b></h3>

                            <p class="fs-6 mb-4">
                                En la función setup(), que se ejecuta una sola vez al inicio, se inicia la comunicación serial a 
                                9600 baudios. Luego, en la función loop(), que se ejecuta 
                                repetidamente, se llama a la función freeRam(), que calcula la memoria RAM disponible utilizando 
                                las variables del sistema __heap_start y __brkval, y el resultado se imprime en el monitor 
                                serial cada 3 segundos.
                            </p>

                            <pre>
                                void setup(){
                                    Serial.begin(9600);
                                    Serial.println("Comienza...");
                                  }
                                  
                                  void loop(){
                                    Serial.println(freeRam());
                                    
                                    delay(3000);
                                  }
                                  
                                  int freeRam () 
                                  {
                                    extern int __heap_start, *__brkval; 
                                    int v; 
                                    return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval); 
                                  }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/424701586945245185"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/memoria_RAM_arduino.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/Memoria_RAM_Arduino.ino">Arduino Memoria RAM</a></p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Comunicacion UART-SERIAL</b></h3>

                            <p class="fs-6 mb-4">
                                Para este código, en la función setup(), que se ejecuta una sola vez al inicio, se establece el 
                                pin 13 como salida y el pin 10 como entrada.Luego, en la función loop(), que se ejecuta 
                                repetidamente, se lee el estado del botón conectado al pin 10. Posteriormente, el estado del 
                                LED en el pin 13 se actualiza, de modo que si el botón está presionado, el LED se enciende, y 
                                si el botón no está presionado, el LED se apaga. En esencia este código hace la misma función
                                que el código pasado solo que ahora usamos condiconales para leer el estado del botón. 
                            </p>

                            <pre>
                                int led=13;
                                int boton=10;
                                bool status_boton=LOW;
                                void setup() {
                                    // put your setup code here, to run once:
                                    pinMode(led, OUTPUT);  
                                    pinMode(boton, INPUT);
                                }

                                void loop() {
                                    // put your main code here, to run repeatedly:
                                    status_boton=digitalRead(boton);
                                    if (status_boton==HIGH){
                                        digitalWrite(led, HIGH);
                                      }
                                      else{
                                        digitalWrite(led,LOW);
                                    
                                      }
                                }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/423424050260464641"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/Arduino boton if.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/Arduino_boton_if.ino">Arduino Botón con if</a></p>



                            

                            <h2 class="fw-bolder mb-4 mt-5 fs-5"><b>ESP32</b></h2>
                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Encendido de un led</b></h3>

                            <p class="fs-6 mb-4">
                                Para este primer, se configura el pin 25 como salida y lo mantiene encendido de forma permanente. 
                                En la función setup(), que se ejecuta una sola vez al inicio, se establece el pin 25 
                                como salida. Luego, en la función loop(), que se ejecuta repetidamente, en donde se establece 
                                el pin 25 en estado alto, lo que hace que el LED conectado permanezca encendido sin interrupción. 
                            </p>

                            <pre>
                                void setup() {
                                    // put your setup code here, to run once:
                                    pinMode(25, OUTPUT);
                                  
                                  }
                                  
                                  void loop() {
                                    // put your main code here, to run repeatedly:
                                    digitalWrite(25, HIGH);
                                  
                                  }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/423426626761071617"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/ESP32_ENCENDIDO_VIDEO.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/ESP32_ENCENDIDO_CODE.ino">ESP32 Encendido</a></p>
                            
                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Parpadeo de un led</b></h3>

                            <p class="fs-6 mb-4">
                                Para este código, en la función setup(), que se ejecuta una sola vez al inicio, se establece el 
                                pin 13 como salida. Luego, en la función loop(), que se ejecuta repetidamente, se establece el 
                                pin 13 en estado alto, lo que hace que el LED conectado se encienda. Posteriormente, se 
                                hace una pausa de 500 milisegundos. Después de la pausa, el pin 13 se pone en estado bajo, 
                                apagando el LED, seguido de otra pausa de 500 milisegundos.
                            </p>

                            <pre>
                                void setup() {
                                    // put your setup code here, to run once:
                                  pinMode(25, OUTPUT);
                                  }
                                  
                                  void loop() {
                                    // put your main code here, to run repeatedly:
                                   digitalWrite(25, HIGH); 
                                  delay(500);
                                  digitalWrite(25, LOW);
                                  delay(500);
                                  }
                                  
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/423427278362078209"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/ESP32_PARPADEO_VIDEO.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/ESP32_PARPADEO_CODE/">ESP32 Parpadeo</a></p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Control del estado del LED mediante un botón</b></h3>

                            <p class="fs-6 mb-4">
                                Para este código, en la función setup(), que se ejecuta una sola vez al inicio, se establece el 
                                pin 25 como salida y el pin 12 como entrada.Luego, en la función loop(), que se ejecuta 
                                repetidamente, se lee el estado del botón conectado al pin 12. Posteriormente, el estado del 
                                LED en el pin 25 se actualiza, de modo que si el botón está presionado, el LED se enciende, y 
                                si el botón no está presionado, el LED se apaga.
                            </p>

                            <pre>
                                int led=13;
                                int boton=12;
                                bool status_boton=0;
                                void setup() {
                                    // put your setup code here, to run once:
                                    pinMode(led, OUTPUT);  
                                    pinMode(boton, INPUT);
                                }

                                void loop() {
                                    // put your main code here, to run repeatedly:
                                    status_boton=digitalRead(boton);
                                    digitalWrite(led,status_boton);
                                }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/423428224722017281"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/ESP32_BOTON_VIDEO.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/ESP32_BOTON_CODE.ino">ESP32 Botón</a></p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Control del estado del LED mediante un botón utilizando condicionales if/else.</b></h3>

                            <p class="fs-6 mb-4">
                                Para este código, en la función setup(), que se ejecuta una sola vez al inicio, se establece el 
                                pin 25 como salida y el pin 12 como entrada. Luego, en la función loop(), que se ejecuta 
                                repetidamente, se lee el estado del botón conectado al pin 12. Posteriormente, el estado del 
                                LED en el pin 25 se actualiza, de modo que si el botón está presionado, el LED se enciende, y 
                                si el botón no está presionado, el LED se apaga. En esencia este código hace la misma función
                                que el código pasado solo que ahora usamos condiconales para leer el estado del botón. 
                            </p>

                            <pre>
                                int led=25;
                                int boton=12;
                                bool status_boton=LOW;
                                void setup() {
                                    // put your setup code here, to run once:
                                    pinMode(led, OUTPUT);  
                                    pinMode(boton, INPUT);
                                }

                                void loop() {
                                    // put your main code here, to run repeatedly:
                                    status_boton=digitalRead(boton);
                                    if (status_boton==HIGH){
                                        digitalWrite(led, HIGH);
                                      }
                                      else{
                                        digitalWrite(led,LOW);
                                      }
                                }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/423428797351520257"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/ESP32_BOTONIF_VIDEO.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/ESP32_BOTONIF_CODE.ino">ESP32 Botón con if</a></p>


                            <h2 class="fw-bolder mb-4 mt-5 fs-5"><b>ATtiny85</b></h2>
                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Encendido de un led</b></h3>

                            <p class="fs-6 mb-4">
                                Para este primer, se configura el pin 3 como salida y lo mantiene encendido de forma permanente. 
                                En la función setup(), que se ejecuta una sola vez al inicio, se establece el pin 3 
                                como salida. Luego, en la función loop(), que se ejecuta repetidamente, en donde se establece 
                                el pin 3 en estado alto, lo que hace que el LED conectado permanezca encendido sin interrupción. 
                            </p>

                            <pre>
                                void setup() {
                                    // put your setup code here, to run once:
                                    pinMode(3, OUTPUT);
                                  
                                  }
                                  
                                  void loop() {
                                    // put your main code here, to run repeatedly:
                                    digitalWrite(3, HIGH);
                                  
                                  }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/423430291157363713"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/ATTINY85_ENCENDIDO_CODE.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/ATiny85_ENCENDIDO_CODE.ino">ATtiny85 Encendido</a></p>
                            
                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Parpadeo de un led</b></h3>

                            <p class="fs-6 mb-4">
                                Para este código, en la función setup(), que se ejecuta una sola vez al inicio, se establece el 
                                pin 3 como salida. Luego, en la función loop(), que se ejecuta repetidamente, se establece el 
                                pin 3 en estado alto, lo que hace que el LED conectado se encienda. Posteriormente, se 
                                hace una pausa de 500 milisegundos. Después de la pausa, el pin 3 se pone en estado bajo, 
                                apagando el LED, seguido de otra pausa de 500 milisegundos.
                            </p>

                            <pre>
                                void setup() {
                                    // put your setup code here, to run once:
                                  pinMode(3, OUTPUT);
                                  }
                                  
                                  void loop() {
                                    // put your main code here, to run repeatedly:
                                   digitalWrite(3, HIGH); 
                                  delay(500);
                                  digitalWrite(3, LOW);
                                  delay(500);
                                  }
                                  
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/423430586377700353"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/ATTINY85_PARPADEO_CODE.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/ATiny85_PARPADEO_CODE.ino">ATtiny85 Parpadeo</a></p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Control del estado del LED mediante un botón</b></h3>

                            <p class="fs-6 mb-4">
                                Para este código, en la función setup(), que se ejecuta una sola vez al inicio, se establece el 
                                pin 3 como salida y el pin 4 como entrada.Luego, en la función loop(), que se ejecuta 
                                repetidamente, se lee el estado del botón conectado al pin 4. Posteriormente, el estado del 
                                LED en el pin 3 se actualiza, de modo que si el botón está presionado, el LED se enciende, y 
                                si el botón no está presionado, el LED se apaga.
                            </p>

                            <pre>
                                int led=3;
                                int boton=4;
                                bool status_boton=0;
                                void setup() {
                                    // put your setup code here, to run once:
                                    pinMode(led, OUTPUT);  
                                    pinMode(boton, INPUT);
                                }

                                void loop() {
                                    // put your main code here, to run repeatedly:
                                    status_boton=digitalRead(boton);
                                    digitalWrite(led,status_boton);
                                }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/423431221664905217"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/ATTINY85_BOTON_CODE.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/ATiny85_BOTON_CODE/">ATtiny85 Botón</a></p>

                            <h3 class="fw-bolder mb-4 mt-5 fs-5"><b>Control del estado del LED mediante un botón utilizando condicionales if/else.</b></h3>

                            <p class="fs-6 mb-4">
                                Para este código, en la función setup(), que se ejecuta una sola vez al inicio, se establece el 
                                pin 3 como salida y el pin 4 como entrada. Luego, en la función loop(), que se ejecuta 
                                repetidamente, se lee el estado del botón conectado al pin 4. Posteriormente, el estado del 
                                LED en el pin 3 se actualiza, de modo que si el botón está presionado, el LED se enciende, y 
                                si el botón no está presionado, el LED se apaga. En esencia este código hace la misma función
                                que el código pasado solo que ahora usamos condiconales para leer el estado del botón. 
                            </p>

                            <pre>
                                int led=3;
                                int boton=4;
                                bool status_boton=LOW;
                                void setup() {
                                    // put your setup code here, to run once:
                                    pinMode(led, OUTPUT);  
                                    pinMode(boton, INPUT);
                                }

                                void loop() {
                                    // put your main code here, to run repeatedly:
                                    status_boton=digitalRead(boton);
                                    if (status_boton==HIGH){
                                        digitalWrite(led, HIGH);
                                      }
                                      else{
                                        digitalWrite(led,LOW);
                                      }
                                }
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Simulación</b></h1>
                            <iframe
                                src="https://wokwi.com/projects/423431619697078273"
                                width="100%"
                                height="600px"
                                style="border: none;">
                            </iframe>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Video</b></h1>
                            <center><figure class="mb-4" align="center">
                                <video width="50%" height="300" controls>
                                    <source src="video/ATTINY85_BOTONIF_CODE.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/ATiny85_BOTONIF_CODE.ino">ATtiny85 Botón con if</a></p>

                        <p id="conclusiones">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Conclusiones -</h2>
                        <p class="fs-6 mb-4">
                            Para concluir, la comparación entre el Arduino UNO, el ESP32 y el ATtiny85 nos ha permitido analizar sus 
                            diferencias por ejemplo, en el Arduino UNO y el ESP32 pueden programarse directamente mediante un cable USB, 
                            mientras que el ATtiny85 requiere un programador externo.
                        </p>
                        
                        <p class="fs-6 mb-4">
                            En cuanto a las características técnicas, el ESP32 destacó por su mayor capacidad de procesamiento 
                            y conectividad, el Arduino UNO por su facilidad de uso, y el ATtiny85 por su tamaño compacto y bajo 
                            consumo energético.
                        </p>

                        <p id="referencias">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Referencias -</h2>
                        <p class="fs-6 mb-4">Santos, S., & Santos, S. (2024, 24 octubre). ESP32 Pinout Reference: Which GPIO pins should you use? | Random Nerd Tutorials. Random Nerd Tutorials. <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">https://randomnerdtutorials.com/esp32-pinout-reference-gpios/</a> </p>
                        <p class="fs-6 mb-4">The Full Arduino Uno Pinout Guide [including diagram]. (2018, 18 noviembre). circuito.io Blog. <a href="https://www.circuito.io/blog/arduino-uno-pinout/"> https://www.circuito.io/blog/arduino-uno-pinout/</a></p>
                        <p class="fs-6 mb-4">Homemade hardware. (s. f.). <a href="http://homemadehardware.com/guides/programming-an-attiny85/"> http://homemadehardware.com/guides/programming-an-attiny85/</a></p>
                        
                        <p id="descargables">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Descargables -</h2>
                        <p class="fs-6 mb-4">Arduino UNO Datasheet: <a href="files/A000066.PDF">Arduino UNO.pdf</a> </p>
                        <p class="fs-6 mb-4">ESP32 Datasheet: <a href="files/esp32-wroom-32_datasheet_en.pdf">ESP32.pdf</a> </p>
                        <p class="fs-6 mb-4">Attiny85 Datasheet: <a href="files/ATTINY25.PDF">Attiny85.pdf</a> </p>
                        <p class="fs-6 mb-4">Descargar carpeta con todos los códigos: <a href="files/Códigos.zip">códigos.zip</a> </p>

                </div>
            </section>

            
        </main>

        <!-- Footer-->
        <footer class="bg-dark py-4 mt-auto">
            <div class="container px-5">
                <div class="row align-items-center justify-content-between flex-column flex-sm-row">
                    <div class="col-auto"><div class="small m-0 text-white">Copyright &copy; Ingenierias-iberopuebla.mx 2023</div></div>
                    <div class="col-auto">
                        <a class="link-light small" href="#!">Privacy</a>
                        <span class="text-white mx-1">&middot;</span>
                        <a class="link-light small" href="#!">Terms</a>
                        <span class="text-white mx-1">&middot;</span>
                        <a class="link-light small" href="#!">Contact</a>
                    </div>
                </div>
            </div>
        </footer>

        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
