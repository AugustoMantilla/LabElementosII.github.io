<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Práctica 4 | Ibero Puebla</title>
        <!-- Favicon-->
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Bootstrap icons-->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel="stylesheet" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />

        <style>
            pre {
                background-color: #fefcfc;
                color: #373e43;
                padding: 15px;
                border-radius: 5px;
                overflow-x: auto;
                white-space: pre-wrap; /* Para que el código se ajuste al contenedor */
                font-size: 14px;
                line-height: 1;
            }
        </style>
    </head>
    <body class="d-flex flex-column h-100">
        <main class="flex-shrink-0">
            <!-- Navigation-->
            <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
                <div class="container px-5">
                    <a class="navbar-brand">Menu</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarSupportedContent">
                        <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
                            <li class="nav-item"><a class="nav-link" href="../">Home</a></li>                    
                            <li class="nav-item"><a class="nav-link" href="../index.html#resumen">Acerca de mi</a></li>
                            <li class="nav-item"><a class="nav-link" href="../index.html#practicas">Prácticas</a></li>
                        </ul>
                    </div>
                </div>
            </nav>

            <!-- Seccion TITULO de Portafolio-->
            <header class="bg-primary py-2 mt-6">
                <div class="container px-5">
                    <div class="row gx-5 align-items-center justify-content-center">
                        <div class="col-lg-8 col-xl-7 col-xxl-6">
                            <div class="my-5 text-center text-xl-start">
                                <h1 class="display-6 fw-bolder text-white mb-2">Portafolio de Actividades</h1>
                                <h1 class="display-8 fw-bolder text-white mb-2">Laboratorio Elementos Programables II</h1>
                                <p id="resumen" class="display-8 fw-normal text-white-50 mb-4">Departamento de Ciencias e Ingenierías | Universidad Iberoamericana Puebla, México.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Seccion TITULO de la Práctica-->
            <section class="py-3" id="scroll-target">
                <div class="container px-5 my-2">
                    <!-- Post header-->
                    <header class="mb-4">
                        <!-- Post title-->
                        <h1 class="fw-bolder mb-1">MQTT</h1>

                        <!-- ETIQUETA DE ALUMNO (Hacer una por cada alumno)-->
                            <div class="ms-2">
                                <div class="fw-bold">Augusto Mantilla Molina</div>
                                <div class="text-muted">Ingeniería Mecatrónica</div>
                            </div>

                            <div class="ms-2">
                                <div class="fw-bold">Carlos Juarez Galicia</div>
                                <div class="text-muted">Ingeniería Mecatrónica</div>
                            </div>
                        <!--Aqui termina etiqueta de alumno-->

                        <div class="text-muted fst-italic mt-2 mb-2">Fecha: Abril 10, 2025</div>
                        <!-- ETIQUETAS O TOPICOS IMPORTANTES DE LA PRACTICA-->
                        <a class="badge bg-primary text-decoration-none link-light" >ESP32</a>
                        <a class="badge bg-primary text-decoration-none link-light" >MQTT</a>

                    </header>
                </div>
            </section>

            <!-- Seccion de CONTENIDO de la Práctica-->
            <section>
                <div class="container px-5">

                    <figure class="mb-4"><img class="img-fluid rounded" width="800px" src="img/" alt="..." /></figure>
                        <p id="intro">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5" >- Introducción -</h2>
                        <p class="fs-6 mb-4">
                            MQTT es un protocolo de mensajería ligero basado en el modelo publicador/suscriptor, diseñado para 
                            comunicaciones eficientes en redes con recursos limitados o anchos de banda reducidos.
                        </p>
                        <p class="fs-6 mb-4">
                            MQTT funciona a través de un broker que se encarga de distribuir los mensajes entre los dispositivos 
                            que publican (publishers) y los que están suscritos (subscribers) a un determinado tópico. Gracias a 
                            esta arquitectura, los dispositivos no necesitan conocerse directamente entre sí, lo que facilita la 
                            escalabilidad y flexibilidad en sistemas distribuidos.
                        </p>
                        <center><figure class="mb-4"><img class="img-fluid rounded" width="400px" src="img/mqtt.png" alt="..." /></figure></center>

                        <p id="materiales">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5" >- Materiales -</h2>
                        <p class="fs-6 mb-4">
                            <ul>
                                <li><b>ESP32</b>: 1</li>
                                <li><b>Potenciómetro</b>: 1</li>
                                <li><b>Cables</b>: 3</li>
                            </ul>
                        </p>
                        <p id="desarrollo">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Desarrollo -</h2>
                        <p class="fs-6 mb-4">
                            La práctica realizada tuvo como objetivo explorar el funcionamiento del protocolo MQTT a través de 
                            una serie de pruebas tanto desde la computadora como desde un microcontrolador ESP32. La primera 
                            parte consistió en enviar datos desde la computadora a través de MQTT, midiendo el tiempo que tardaba 
                            un mensaje en ir y regresar. Para ello, se enviaron 1000 mensajes y se midió el tiempo individual de 
                            cada uno. Una vez obtenidos todos los datos, se calcularon el tiempo promedio, la desviación 
                            estándar, y se realizó una gráfica con los resultados.
                        </p>

                        <p class="fs-6 mb-4">
                            En la segunda parte de la práctica se repitió el mismo procedimiento, pero esta vez los mensajes 
                            fueron enviados desde un ESP32. Al igual que en el anterior, se registraron los tiempos de ida 
                            y vuelta para 1000 mensajes, y posteriormente se analizaron los datos obtenidos.
                        </p>
                        
                        <p class="fs-6 mb-4">
                            En la tercera parte, se implementó una comunicación en la que la computadora enviaba un mensaje 
                            mediante MQTT y el ESP32 lo recibía. Esta prueba permitió verificar la correcta recepción de mensajes 
                            en el microcontrolador desde un cliente MQTT ejecutado en la computadora.
                        </p>

                        <p class="fs-6 mb-4">
                            Finalmente, en la última parte de la práctica, se conectó un potenciómetro al ESP32 para enviar por 
                            MQTT los valores leídos de un potenciómetro. Esta información se transmitía de forma continua al broker MQTT, 
                            lo que permitió observar en tiempo real los datos generados por el sensor.
                        </p>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Primera parte</b></h1>
                            <p class="fs-6 mb-4">
                                En Python se conecta al broker público test.mosquitto.org y mide el tiempo de ida y vuelta de 
                                10000 mensajes enviados al tópico "elementos2/augusto". Al recibir el mismo mensaje de vuelta, 
                                se calcula la latencia comparando el tiempo actual con el tiempo de envío. Todos los tiempos se 
                                almacenan en una lista para luego calcular el promedio y la desviación estándar. Finalmente, se 
                                genera una gráfica que muestra la latencia de cada mensaje, junto con líneas que indican el 
                                promedio y los límites de una desviación estándar.
                            </p>

                            <pre>
                                import paho.mqtt.client as mqtt
                                import time
                                import numpy as np
                                import matplotlib.pyplot as plt

                                # Configuración del broker MQTT
                                BROKER = "test.mosquitto.org"  # Puedes cambiarlo por tu broker
                                TOPIC = "elementos2/augusto"
                                NUM_MESSAGES = 10000  # Ajustado a 10000 para coincidir con la imagen

                                times = []  # Lista para almacenar los tiempos de ida y vuelta
                                sent_times = {}  # Diccionario para almacenar los tiempos de envío

                                def on_connect(client, userdata, flags, rc):
                                    print("Conectado al broker MQTT con código de resultado:", rc)
                                    client.subscribe(TOPIC)

                                def on_message(client, userdata, msg):
                                    global times
                                    receive_time = time.time()
                                    msg_id = int(msg.payload.decode())
                                    if msg_id in sent_times:
                                        round_trip_time = receive_time - sent_times[msg_id]
                                        times.append(round_trip_time)
                                        del sent_times[msg_id]  # Remover mensaje procesado

                                def main():
                                    client = mqtt.Client()
                                    client.on_connect = on_connect
                                    client.on_message = on_message
                                    client.connect(BROKER, 1883, 60)
                                    client.loop_start()
                                    
                                    print("Enviando mensajes...")
                                    for i in range(NUM_MESSAGES):
                                        sent_times[i] = time.time()
                                        client.publish(TOPIC, str(i))
                                        time.sleep(0.005)  # Reducida la pausa para más mensajes
                                    
                                    time.sleep(5)  # Esperar a recibir respuestas
                                    client.loop_stop()
                                    client.disconnect()
                                    
                                    if times:
                                        promedio = np.mean(times)
                                        desviacion = np.std(times)
                                        
                                        plt.figure(figsize=(10, 6))
                                        plt.scatter(range(len(times)), times, color='blue', s=1, alpha=0.6, label="Latency (s)")
                                        plt.axhline(promedio, color='green', linestyle='dashed', label=f'Mean = {promedio:.4f} s')
                                        plt.axhline(promedio + desviacion, color='orange', linestyle='dashed', label=f'+1 Std Dev = {promedio + desviacion:.4f} s')
                                        plt.axhline(promedio - desviacion, color='red', linestyle='dashed', label=f'-1 Std Dev = {promedio - desviacion:.4f} s')
                                        
                                        plt.xlabel("Message Index")
                                        plt.ylabel("Δt (s)")
                                        plt.title("MQTT Message Latency")
                                        plt.legend()
                                        plt.grid(True, linestyle='--', alpha=0.7)
                                        plt.show()
                                    else:
                                        print("No se recibieron respuestas.")

                                if __name__ == "__main__":
                                    main()
                            </pre>
                            <center><figure class="mb-4"><img class="img-fluid rounded" width="400px" src="img/primeraparte.png" alt="..." /></figure></center>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Explicación</b></h1>
                            <p class="fs-6 mb-4">
                                Se importan las librerías serial para la comunicación serie y time para manejar tiempos y retardos.
                            </p>

                            <p class="fs-6 mb-4">
                                Se crea una instancia de serial.Serial para comunicarse por medio del  puerto "COMX" a una 
                                velocidad de X baudios, con un tiempo de espera de 0.1 segundos.
                            </p>

                            <p class="fs-6 mb-4">
                                Se espera 2 segundos para asegurar que la conexión esté establecida.
                            </p>

                            <p class="fs-6 mb-4">
                                Se crea una lista para guardar los tiempos de ida y vuelta
                            </p>

                            <p class="fs-6 mb-4">
                                Se crea un buble de 100 interaciones en donde:
                            </p>
                            <p class="fs-6 mb-4">
                                <ol>
                                    <li>Se limpia el buffer de entrada del puerto serie. </li>
                                    <li>Se registra el tiempo de inicio.</li>
                                    <li>Se envía un byte "A" al dispositivo.</li>
                                    <li>Se lee la respuesta del dispositivo.</li>
                                    <li>Si la respuesta es "A", se registra el tiempo de fin.</li>
                                    <li>Se calcula el tiempo de ida y vuelta en milisegundos y se añade a la lista tiempos.</li>
                                </ol>
                            </p>
                            
                            <p class="fs-6 mb-4">
                                Cuando se termina de recopilar los tiempos, se calcula el promedio del tiempo de ida y vuelta 
                                y se imprime con cuatro decimales.
                            </p>

                            <p class="fs-6 mb-4">
                                Por último, se cierra la conexión del puerto serie.
                            </p>

                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/codigopython.py">Código pyhton</a></p>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Código de Arduino</b></h1>
                            <p class="fs-6 mb-4">
                                Se utiliza un código en Arduino IDE porque permite recibir y reenviar datos a la computadora de 
                                manera inmediata, lo que es útil para probar la comunicación serial, depurar programas y 
                                asegurarse de que los datos se transmiten correctamente. 
                            </p>

                            <pre>
                                void setup() {
                                    Serial.begin(2000000);
                                  }
                                  
                                  void loop() {
                                    if (Serial.available() > 0) { 
                                      char r = Serial.read();  
                                      Serial.println(r);  
                                    }
                                  }
                            </pre>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/arduino_computadora.ino">Código arduino</a></p>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Explicación</b></h1>
                            <p class="fs-6 mb-4">
                                Para el codigo en Arduino IDE se establece una comunicación serial a <b>x</b> baudios en el 
                                setup(), lo que permite una transmisión de datos más rápida. En el loop(), verifica si hay datos 
                                disponibles en el puerto serial; si los hay, lee un carácter y lo reenvía de vuelta a la 
                                computadora, funcionando así como un eco de cualquier dato recibido.
                            </p>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Funcionamiento de ambos códigos</b></h1>
                            <p class="fs-6 mb-4">
                                Para implementar ambos códigos, es importante tener nuestro microcontrolador conectado a la 
                                computadora mediante un cable USB-UART. Una vez conectado, cargamos el código en Arduino IDE y 
                                esperamos a que la carga finalice. Es fundamental cerrar el Monitor Serial de Arduino IDE, ya 
                                que, de lo contrario, no podremos realizar la operación correctamente en Python. Una vez que 
                                el código se haya subido, ejecutamos el código en Python, esperamos a que termine de realizar 
                                las operaciones y, al finalizar, obtendremos el promedio del tiempo de transmisión.
                            </p>

                            <h2 class="fw-bolder mb-4 mt-5 fs-5"><b>Arduino UNO</b></h2>
                            <center><figure class="mb-4" align="center">
                                <video width="70%" height="500" controls>
                                    <source src="video/arduino uno bien.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>

                            <h2 class="fw-bolder mb-4 mt-5 fs-5"><b>ESP32</b></h2>
                            <center><figure class="mb-4" align="center">
                                <video width="70%" height="500" controls>
                                    <source src="video/esp32 bien.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>


                            
                        <div>
                        <p id="conclusiones">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Conclusiones -</h2>
                        <p class="fs-6 mb-4">
                            La comunicación serial es un método eficiente para transmitir datos a gran velocidad. Se realizaron 
                            pruebas en dos microcontroladores, obteniendo resultados muy buenos, ya que el tiempo promedio de ida 
                            y vuelta fue bastante rápido. La única desventaja es que la velocidad de transmisión depende del 
                            microcontrolador, ya que algunos no cuentan con una velocidad serial muy alta y otros ni siquiera 
                            disponen de un puerto serial como en ATtiny85.
                        </p>

                        <p id="referencias">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Referencias -</h2>
                        <p class="fs-6 mb-4">Santos, S., & Santos, S. (2024, 24 octubre). ESP32 Pinout Reference: Which GPIO pins should you use? | Random Nerd Tutorials. Random Nerd Tutorials. <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">https://randomnerdtutorials.com/esp32-pinout-reference-gpios/</a> </p>
                        <p class="fs-6 mb-4">The Full Arduino Uno Pinout Guide [including diagram]. (2018, 18 noviembre). circuito.io Blog. <a href="https://www.circuito.io/blog/arduino-uno-pinout/"> https://www.circuito.io/blog/arduino-uno-pinout/</a></p>
                        
                        <p id="descargables">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Descargables -</h2>
                        <p class="fs-6 mb-4">Arduino UNO Datasheet: <a href="files/A000066.PDF">Arduino UNO.pdf</a> </p>
                        <p class="fs-6 mb-4">ESP32 Datasheet: <a href="files/esp32-wroom-32_datasheet_en.pdf">ESP32.pdf</a> </p>
                        <p class="fs-6 mb-4">Attiny85 Datasheet: <a href="files/ATTINY25.PDF">Attiny85.pdf</a> </p>
                </div>
            </section>

            
        </main>

        <!-- Footer-->
        <footer class="bg-dark py-4 mt-auto">
            <div class="container px-5">
                <div class="row align-items-center justify-content-between flex-column flex-sm-row">
                    <div class="col-auto"><div class="small m-0 text-white">Copyright &copy; Ingenierias-iberopuebla.mx 2023</div></div>
                    <div class="col-auto">
                        <a class="link-light small" href="#!">Privacy</a>
                        <span class="text-white mx-1">&middot;</span>
                        <a class="link-light small" href="#!">Terms</a>
                        <span class="text-white mx-1">&middot;</span>
                        <a class="link-light small" href="#!">Contact</a>
                    </div>
                </div>
            </div>
        </footer>

        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
