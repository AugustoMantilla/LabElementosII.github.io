<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Práctica 4 | Ibero Puebla</title>
        <!-- Favicon-->
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Bootstrap icons-->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel="stylesheet" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />

        <style>
            pre {
                background-color: #fefcfc;
                color: #373e43;
                padding: 15px;
                border-radius: 5px;
                overflow-x: auto;
                white-space: pre-wrap; /* Para que el código se ajuste al contenedor */
                font-size: 14px;
                line-height: 1;
            }
        </style>
    </head>
    <body class="d-flex flex-column h-100">
        <main class="flex-shrink-0">
            <!-- Navigation-->
            <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
                <div class="container px-5">
                    <a class="navbar-brand">Menu</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarSupportedContent">
                        <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
                            <li class="nav-item"><a class="nav-link" href="../">Home</a></li>                    
                            <li class="nav-item"><a class="nav-link" href="../index.html#resumen">Acerca de mi</a></li>
                            <li class="nav-item"><a class="nav-link" href="../index.html#practicas">Prácticas</a></li>
                        </ul>
                    </div>
                </div>
            </nav>

            <!-- Seccion TITULO de Portafolio-->
            <header class="bg-primary py-2 mt-6">
                <div class="container px-5">
                    <div class="row gx-5 align-items-center justify-content-center">
                        <div class="col-lg-8 col-xl-7 col-xxl-6">
                            <div class="my-5 text-center text-xl-start">
                                <h1 class="display-6 fw-bolder text-white mb-2">Portafolio de Actividades</h1>
                                <h1 class="display-8 fw-bolder text-white mb-2">Laboratorio Elementos Programables II</h1>
                                <p id="resumen" class="display-8 fw-normal text-white-50 mb-4">Departamento de Ciencias e Ingenierías | Universidad Iberoamericana Puebla, México.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Seccion TITULO de la Práctica-->
            <section class="py-3" id="scroll-target">
                <div class="container px-5 my-2">
                    <!-- Post header-->
                    <header class="mb-4">
                        <!-- Post title-->
                        <h1 class="fw-bolder mb-1">MQTT</h1>

                        <!-- ETIQUETA DE ALUMNO (Hacer una por cada alumno)-->
                            <div class="ms-2">
                                <div class="fw-bold">Augusto Mantilla Molina</div>
                                <div class="text-muted">Ingeniería Mecatrónica</div>
                            </div>

                            <div class="ms-2">
                                <div class="fw-bold">Carlos Juarez Galicia</div>
                                <div class="text-muted">Ingeniería Mecatrónica</div>
                            </div>
                        <!--Aqui termina etiqueta de alumno-->

                        <div class="text-muted fst-italic mt-2 mb-2">Fecha: Abril 10, 2025</div>
                        <!-- ETIQUETAS O TOPICOS IMPORTANTES DE LA PRACTICA-->
                        <a class="badge bg-primary text-decoration-none link-light" >ESP32</a>
                        <a class="badge bg-primary text-decoration-none link-light" >MQTT</a>

                    </header>
                </div>
            </section>

            <!-- Seccion de CONTENIDO de la Práctica-->
            <section>
                <div class="container px-5">

                    <figure class="mb-4"><img class="img-fluid rounded" width="800px" src="img/" alt="..." /></figure>
                        <p id="intro">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5" >- Introducción -</h2>
                        <p class="fs-6 mb-4">
                            MQTT es un protocolo de mensajería ligero basado en el modelo publicador/suscriptor, diseñado para 
                            comunicaciones eficientes en redes con recursos limitados o anchos de banda reducidos.
                        </p>
                        <p class="fs-6 mb-4">
                            MQTT funciona a través de un broker que se encarga de distribuir los mensajes entre los dispositivos 
                            que publican (publishers) y los que están suscritos (subscribers) a un determinado tópico. Gracias a 
                            esta arquitectura, los dispositivos no necesitan conocerse directamente entre sí, lo que facilita la 
                            escalabilidad y flexibilidad en sistemas distribuidos.
                        </p>
                        <center><figure class="mb-4"><img class="img-fluid rounded" width="400px" src="img/mqtt.png" alt="..." /></figure></center>

                        <p class="fs-6 mb-4">
                            La práctica realizada tuvo como objetivo explorar el funcionamiento del protocolo MQTT a través de 
                            una serie de pruebas tanto desde la computadora como desde un microcontrolador ESP32. La primera 
                            parte consistió en enviar datos desde la computadora a través de MQTT, midiendo el tiempo que tardaba 
                            un mensaje en ir y regresar. Para ello, se enviaron 1000 mensajes y se midió el tiempo individual de 
                            cada uno. Una vez obtenidos todos los datos, se calcularon el tiempo promedio, la desviación 
                            estándar, y se realizó una gráfica con los resultados.
                        </p>

                        <p class="fs-6 mb-4">
                            En la segunda parte de la práctica se repitió el mismo procedimiento, pero esta vez los mensajes 
                            fueron enviados desde un ESP32. Al igual que en el anterior, se registraron los tiempos de ida 
                            y vuelta para 1000 mensajes, y posteriormente se analizaron los datos obtenidos.
                        </p>
                        
                        <p class="fs-6 mb-4">
                            En la tercera parte, se implementó una comunicación en la que la computadora enviaba un mensaje 
                            mediante MQTT y el ESP32 lo recibía. Esta prueba permitió verificar la correcta recepción de mensajes 
                            en el microcontrolador desde un cliente MQTT ejecutado en la computadora.
                        </p>

                        <p class="fs-6 mb-4">
                            Finalmente, en la última parte de la práctica, se conectó un potenciómetro al ESP32 para enviar por 
                            MQTT los valores leídos de un potenciómetro. Esta información se transmitía de forma continua al broker MQTT, 
                            lo que permitió observar en tiempo real los datos generados por el sensor.
                        </p>

                        <p id="materiales">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5" >- Materiales -</h2>
                        <p class="fs-6 mb-4">
                            <ul>
                                <li><b>ESP32</b>: 1</li>
                                <li><b>Potenciómetro</b>: 1</li>
                                <li><b>Cables</b>: 3</li>
                            </ul>
                        </p>
                        <p id="desarrollo">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Desarrollo -</h2>
                        <p class="fs-6 mb-4">
                            En esta práctica, se evaluará el tiempo de ida y vuelta de una comunicación serial entre un 
                            microcontrolador y una computadora. Para ello, se enviará un dato desde la PC hacia el microcontrolador, 
                            el cual responderá con el mismo dato, y se medirá el tiempo transcurrido en la PC.
                        </p>
                        <p class="fs-6 mb-4">
                            El objetivo es analizar la latencia en la comunicación serial y obtener un promedio del tiempo de 
                            respuesta después de 100 iteraciones.
                        </p>
                            
                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Código de Python</b></h1>
                            <p class="fs-6 mb-4">
                                Para esta práctica, es necesario descargar <b><a href="https://www.python.org/">Python</a></b> porque se utilizará para establecer la 
                                comunicación serial entre la PC y el microcontrolador mediante la librería pyserial, 
                                la cual permite enviar y recibir datos a través del puerto USB. Además, Python nos permite 
                                medir con precisión el tiempo de ida y vuelta de los datos, realizar múltiples iteraciones y 
                                calcular el tiempo promedio de respuesta, algo que no se puede hacer directamente desde el IDE de 
                                Arduino.
                            </p>

                            <pre>
                                import serial
                                import time

                                micro = serial.Serial("COM15", 2000000, timeout=0.1)
                                time.sleep(2)

                                tiempos = []  

                                for i in range(100):
                                micro.reset_input_buffer() 
                                inicio = time.perf_counter()  

                                micro.write(b"A")
                                respuesta = micro.readline().decode().strip()  
                                if respuesta == "A": 
                                fin = time.perf_counter()  
                                rtt = (fin - inicio) * 1000 
                                tiempos.append(rtt)

                                if tiempos:
                                promedio = sum(tiempos) / len(tiempos)
                                print(f"{promedio:.4f}")

                                micro.close()
                            </pre>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Explicación</b></h1>
                            <p class="fs-6 mb-4">
                                Se importan las librerías serial para la comunicación serie y time para manejar tiempos y retardos.
                            </p>

                            <p class="fs-6 mb-4">
                                Se crea una instancia de serial.Serial para comunicarse por medio del  puerto "COMX" a una 
                                velocidad de X baudios, con un tiempo de espera de 0.1 segundos.
                            </p>

                            <p class="fs-6 mb-4">
                                Se espera 2 segundos para asegurar que la conexión esté establecida.
                            </p>

                            <p class="fs-6 mb-4">
                                Se crea una lista para guardar los tiempos de ida y vuelta
                            </p>

                            <p class="fs-6 mb-4">
                                Se crea un buble de 100 interaciones en donde:
                            </p>
                            <p class="fs-6 mb-4">
                                <ol>
                                    <li>Se limpia el buffer de entrada del puerto serie. </li>
                                    <li>Se registra el tiempo de inicio.</li>
                                    <li>Se envía un byte "A" al dispositivo.</li>
                                    <li>Se lee la respuesta del dispositivo.</li>
                                    <li>Si la respuesta es "A", se registra el tiempo de fin.</li>
                                    <li>Se calcula el tiempo de ida y vuelta en milisegundos y se añade a la lista tiempos.</li>
                                </ol>
                            </p>
                            
                            <p class="fs-6 mb-4">
                                Cuando se termina de recopilar los tiempos, se calcula el promedio del tiempo de ida y vuelta 
                                y se imprime con cuatro decimales.
                            </p>

                            <p class="fs-6 mb-4">
                                Por último, se cierra la conexión del puerto serie.
                            </p>

                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/codigopython.py">Código pyhton</a></p>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Código de Arduino</b></h1>
                            <p class="fs-6 mb-4">
                                Se utiliza un código en Arduino IDE porque permite recibir y reenviar datos a la computadora de 
                                manera inmediata, lo que es útil para probar la comunicación serial, depurar programas y 
                                asegurarse de que los datos se transmiten correctamente. 
                            </p>

                            <pre>
                                void setup() {
                                    Serial.begin(2000000);
                                  }
                                  
                                  void loop() {
                                    if (Serial.available() > 0) { 
                                      char r = Serial.read();  
                                      Serial.println(r);  
                                    }
                                  }
                            </pre>
                            <p class="fs-6 mb-4">Descargar codigo: <a href="files/arduino_computadora.ino">Código arduino</a></p>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Explicación</b></h1>
                            <p class="fs-6 mb-4">
                                Para el codigo en Arduino IDE se establece una comunicación serial a <b>x</b> baudios en el 
                                setup(), lo que permite una transmisión de datos más rápida. En el loop(), verifica si hay datos 
                                disponibles en el puerto serial; si los hay, lee un carácter y lo reenvía de vuelta a la 
                                computadora, funcionando así como un eco de cualquier dato recibido.
                            </p>

                            <h1 class="fw-bolder2 mb-4 mt-5 fs-5"><b>Funcionamiento de ambos códigos</b></h1>
                            <p class="fs-6 mb-4">
                                Para implementar ambos códigos, es importante tener nuestro microcontrolador conectado a la 
                                computadora mediante un cable USB-UART. Una vez conectado, cargamos el código en Arduino IDE y 
                                esperamos a que la carga finalice. Es fundamental cerrar el Monitor Serial de Arduino IDE, ya 
                                que, de lo contrario, no podremos realizar la operación correctamente en Python. Una vez que 
                                el código se haya subido, ejecutamos el código en Python, esperamos a que termine de realizar 
                                las operaciones y, al finalizar, obtendremos el promedio del tiempo de transmisión.
                            </p>

                            <h2 class="fw-bolder mb-4 mt-5 fs-5"><b>Arduino UNO</b></h2>
                            <center><figure class="mb-4" align="center">
                                <video width="70%" height="500" controls>
                                    <source src="video/arduino uno bien.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>

                            <h2 class="fw-bolder mb-4 mt-5 fs-5"><b>ESP32</b></h2>
                            <center><figure class="mb-4" align="center">
                                <video width="70%" height="500" controls>
                                    <source src="video/esp32 bien.mp4" type="video/mp4">
                                </video>
                                </figure>
                            </center>


                            
                        <div>
                        <p id="conclusiones">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Conclusiones -</h2>
                        <p class="fs-6 mb-4">
                            La comunicación serial es un método eficiente para transmitir datos a gran velocidad. Se realizaron 
                            pruebas en dos microcontroladores, obteniendo resultados muy buenos, ya que el tiempo promedio de ida 
                            y vuelta fue bastante rápido. La única desventaja es que la velocidad de transmisión depende del 
                            microcontrolador, ya que algunos no cuentan con una velocidad serial muy alta y otros ni siquiera 
                            disponen de un puerto serial como en ATtiny85.
                        </p>

                        <p id="referencias">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Referencias -</h2>
                        <p class="fs-6 mb-4">Santos, S., & Santos, S. (2024, 24 octubre). ESP32 Pinout Reference: Which GPIO pins should you use? | Random Nerd Tutorials. Random Nerd Tutorials. <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">https://randomnerdtutorials.com/esp32-pinout-reference-gpios/</a> </p>
                        <p class="fs-6 mb-4">The Full Arduino Uno Pinout Guide [including diagram]. (2018, 18 noviembre). circuito.io Blog. <a href="https://www.circuito.io/blog/arduino-uno-pinout/"> https://www.circuito.io/blog/arduino-uno-pinout/</a></p>
                        
                        <p id="descargables">
                        <h2 class="fw-bolder mb-4 mt-5 fs-5">- Descargables -</h2>
                        <p class="fs-6 mb-4">Arduino UNO Datasheet: <a href="files/A000066.PDF">Arduino UNO.pdf</a> </p>
                        <p class="fs-6 mb-4">ESP32 Datasheet: <a href="files/esp32-wroom-32_datasheet_en.pdf">ESP32.pdf</a> </p>
                        <p class="fs-6 mb-4">Attiny85 Datasheet: <a href="files/ATTINY25.PDF">Attiny85.pdf</a> </p>
                </div>
            </section>

            
        </main>

        <!-- Footer-->
        <footer class="bg-dark py-4 mt-auto">
            <div class="container px-5">
                <div class="row align-items-center justify-content-between flex-column flex-sm-row">
                    <div class="col-auto"><div class="small m-0 text-white">Copyright &copy; Ingenierias-iberopuebla.mx 2023</div></div>
                    <div class="col-auto">
                        <a class="link-light small" href="#!">Privacy</a>
                        <span class="text-white mx-1">&middot;</span>
                        <a class="link-light small" href="#!">Terms</a>
                        <span class="text-white mx-1">&middot;</span>
                        <a class="link-light small" href="#!">Contact</a>
                    </div>
                </div>
            </div>
        </footer>

        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
